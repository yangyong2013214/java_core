### 第四章 对象与类

    
#### 4.1 面向对象程序设计概述

    面向对象程序设计（简称OOP)是当今主流的程序设计范型，它已经取代了20世纪70年代的“结构化”过程化程序
    设计开发技术。java是完全面向对象的。
    
    面向对象的程序是由对象组成的，每个对象包对用户公开的特定的功能部分和隐藏的实现部分。程序中的很多
    对象来自标准库，还有一些是自定义的。从根本上说，只要对象能够满足要求，就不必关心其功能的具体实现过程。
    在OOP中，不必关心对象的具体实现，只要能够满足用户的需求即可。
    
    
    传统的结构化程序设计通过设计一系列的过程（即算法）来解决问题。一旦确定了这些过程，就要开始考虑
    存储数据的方式。这就是Pascal语言的设计者Niklaus Wirth 将其著作命名为《算法+数据结构=程序》（Algorithms+
    Data Structures = Programs， Prentice Hall 1975）的原因。在Wirth命名的书名中，算法是第一位的，数据
    结构是第二位的，这就明确地表述了程序员的工作方式，首页要确定如何操作数据，然后再决定如何组织数据，以便于
    数据操作。而OOP却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。
    
    对于一些规模较小的问题，将其分解为过程的开发方式比较理想。而面向对象更加适用于解决规模较大的问题。
    
##### 4.1.1 类

    类（class）是构造对象的模板或蓝图。问可以将类想象成制作小甜饼的切割机，将类想象为小甜饼。
    由类构造（construct）对象的过程称为创建类的实例（instance）。
    
    封装（encapsulation，有时称为数据隐藏）与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合
    在一个包中，并对对象的使用者隐藏了数据的实现方式。
    
    对象中的数据称为实例域（instance field），操纵数据的过程称为方法（method）。对于每个特定的类实例（对象）
    都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state）。无论如何，只要向对象发送一个消息，
    它的状态就有可能发生改变。
    
    实现封装的关键在于绝不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。
    封装给对象赋予了“黑盒”特征，这是提高重用性和可靠性的关键。
    
    OOP的另一个原则会让用户自定义java类变得轻而易举，这就是：可以通过扩展一个类来建立另外一个新的类。事实上，
    在java中，所有的类都源自于一个“神通广大的超类”，他就是Object。在扩展一个已有的类时，这个扩展后的新类
    具有所扩展类的全部属性和方法。
    
    
##### 4.1.2 对象 

    要想使用OOP,一定要弄清楚对象的三个特征
    对象的行为（behavior）——可以对对象施加哪些操作，或可以对对象施加哪些方法？
    对象的状态（state）——当施加那些方法时，对象如何响应？
    对象的标识（identity）—— 如何辨别具有相同行为与状态的不同对象？
    
    同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。
    
    每个对象对保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会
    是自发的。对象的状态改变必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明封装性遭到破坏）

    对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份（identity）.作为一个类的实例，每个对象的标识
    永远是不同的，状态常常也存在着差异。
    
    对象的这些关键特性在彼此之间相互影响者。对象的状态影响它的行为（如果一个订单“已送货”或“已付款”，就应该
    拒绝调用具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预订的物品，这个订单就不应该进入
    “已送货”状态）。
    
##### 4.1.3 识别类
    
    传统的过程化程序设计，必须从顶部的main函数开始编写程序。在面向对象程序设计时没有所谓的“顶部”。对于学习OOP
    的初学者来说常常会感觉无从下手。答案是：首先从设计类开始，然后再往每个类中添加方法。
    
    识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
    如：在订单处理系统中，有这样一些名词：
    项目（item）
    订单（order）
    送货地址（shipping address）
    付款（payment）
    账户（account）
    
##### 4.1.4 类之间的关系

    在类之间，最常见的关系有
    1. 依赖（“uses-a”）
    2. 聚合（“has-a”）
    3. 继承 （“is-a”）   
     
    依赖（dependence），即“uses-a”关系，是一种最明显的，最常见的关系。如：Order类使用Account类是因为
    Order对象需要访问Account对象查看信用状态。但是Item类不依赖于Account类，这是因为Item对象于客户无关。
    因此，如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类
    
    应该尽可能地将相互依赖的类减至最少。如果类A不知道B的存在，它就不会关心B的任何改变（这意味着B的改变
    不会导致A产生任何bug）。用软件工程的术语来说，就说让类之间的耦合度最小。
    
    聚合（aggregation），即“has-a”关系，是一个具体且易于理解的关系。如：一个Order对象包含一些Item对象。
    聚合关系意味着类A的对象包含类B的对象。
    
    继承（inheritance），即“is-a”关系，是一种用于表示特殊与一般关系的。如：RushOrder类由Order类继承而来。
    在具有特殊性的RushOrder类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法；而其他方法，
    如添加条目，生成账单等都是从order类继承来到。
    
    
     
    
#### 4.2  使用预定义类

    在java中，没有类就无法做任何事情。
    
##### 4.2.1  对象与对象变量

    要想使用对象，就必须首先构造对象，并制定其初始状态，在java程序设计语言中，使用构造器（constructor）
    构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。
    
    一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在java中，任何对象变量的值都是对存储在另外
    一个地方的一个对象的引用。new操作符的返回值也是一个引用。
    
##### 4.2.2  java类库中的GregorianCalendar类
    
    类库设计者决定将保持实际与给时间点命名分开。所以标准java类库分别包含了两个类：一个用来表示时间点的Date类，
    另一个是用来表示大家熟悉的日历表示法的GregorianCalendar类。事实上，GregorianCalendar类扩展了一个更加通用的
    Calendar类，这个类描述了日历的一般属性。
    
##### 4.2.3  更改器方法和访问器方法
   
    get方法与set和add方法在概念上是有区别的。get方法仅仅查看并返回对象的状态，而set和add方法却对对象的状态
    进行修改。对实例域做出修改的方法称为更改器方法（mutator method），仅访问实例域而不进行修改的方法称为
    访问器方法（accessor method）。在C++中，带有const后缀的方法时访问器方法；默认为更改器方法。
    
#### 4.3 用户自定义类
    
##### 4.3.1 Employee类

    在一个源文件中，只能有一个公共类，但可以有任意数目的非公有类。
    
##### 4.3.2 多个源文件的使用
   
    当java编译器发现EmployeeTest.java 使用了Employee类时会查找类名为Employee.class文件。如果没有找到这个文件，
    就会自动地搜索Employee.java，然后，对它进行编译。更重要的是：如果Employee.java版本较已有的Employee.class
    文件版本新，java编译器就会自动地重新编译这个文件。
    
    如果熟悉UNIX的“make”工具（或者Windows中的“nmake”等工具），可以认为java编译器内置了“make”功能。
 
##### 4.3.3 剖析Employee类

    类中的方法都被标记为public，关键字private确保只有类自身的方法能够访问这些实例域，而其他类的
    方法不能读写这些域。
    
##### 4.3.4 从构造器开始

    构造器与其他的方法有一个重要的不同。构造器总是伴随着new操作符的执行被调用，而不能对一个已经
    存在的对象调用构造器来达到重新设置实例域的目的。其特点有：
    1.构造器与类名同名
    2.每个类可以有一个以上构造器
    3.构造器可以有0个，1个或多个参数
    4.构造器没有返回值
    5.构造器总是伴随着new操作一起调用
    
    必须注意在所有的方法中不要命名与实例域同名的变量。
    
    
##### 4.3.5 隐式参数与显式参数

    public void raiseSalary(double byPercent)
    {
      double raise = salary * byPercent / 100;
      salary += raise;
    }
    该方法有两个参数，第一个参数称为隐式（implicit）参数，是出现在方法名前的Employee类对象，第二个参数
    位于方法名后面括号中的数值，这是一个显式（explicit）参数。
    
    关键字this表示隐式参数。
   
##### 4.3.6 封装的优点

    在需要获取或设置实例域的值，应提供以下三项：
    1. 一个私有的数据域
    2. 一个公有的域访问器方法
    3. 一个公有的域更改器方法
    
    这样做要比提供一个简单的公有数据域复杂些，但是却有着下列明显的好处：
    1.可以改变内部实现，除了该类的方法之外，不会影响其他代码。
    2. 更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。
    
    不要编写返回引用可变对象的访问器方法。如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone），
    对象clone是指存放在另一个位置上的对象副本。
    
##### 4.3.7 基于类的访问权限

    方法可以访问所属类的私有特性（feature），而不仅限于访问隐式参数的私有特性。

##### 4.3.8 私有方法

    在实现一个类时，由于公有数据非常危险，所以应该将所有的数据域都设置为私有的。尽管绝大多数方法都被设计为
    公有的，但在某些特殊情况下，也可能将他们设计为私有的。
    
##### 4.3.9 final实例域

    final修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域（如果类中的每个方法都不会改变
    其对象，这种类就是不可变的类，如：String）。对于可变的类，使用final修饰符可能会对读者造成混乱。
    
#### 4.4 静态域域静态方法
    
##### 4.4.1 静态域

    如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。如：
    class Employee
    {
        //静态域
        private static int nextId = 1;
        //实例域
        private int id;
     }
     这样，每一个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个nextId域。换句话说，如果有1000个
     Employee类的对象，则有1000个实例域id。但是，只有一个静态域nextId。
     
##### 4.4.2 静态常量

    静态变量使用得比较少，但静态常量却使用得比较多。前面提到过，由于每个类对象都可以对公有域进行修改，所以
    最好不要将域设计为public，然而，公有常量（即final域）却没有问题。因为out被声明为final，所以，不允许
    再将其他打印流赋给它。
    注：System类，有个setOut方法，它可以将System.out设置为不同的流。为什么它可以修改final变量的值。原因
    在于setOut方法是一个本地方法，而不是用Java语言实现的。本地方法可以绕过Java语言的存取控制机制。
   
    
##### 4.4.3 静态方法 

    静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有this参数的方法（在一个非静态的方法中，
    this参数表示这个方法的隐式参数）。因为静态方法不能操作对象，所以不能再静态方法中访问实例域。但是，静态
    方法可以访问自身类中的静态域。
    在下面两种情况下使用静态方法：
    1. 一个方法不需要访问对象状态，其所需参数都是通过显示参数提供（如：Math.pow）
    2. 一个方法只需要访问类的静态域（如：Employee.getNextId）
    
##### 4.4.4 工厂方法

    静态方法还有一个常见的用途。NumberFormat类使用工厂方法产生不同风格的格式对象。
    为什么NumberFormat类不利于构造器完成实例化的操作呢？原因有两点：
    1.无法命名构造器，构造器的名字必须与类名相同。但是，这里希望将得到的货币实例和百分比实例采用不同的名字
    2.当使用构造器时，无法改变所构造的对象类型，而Factory方法返回一个DecimalFormat类对象，这是NumberFormat
    的子类。
    
##### 4.4.5 main方法

    main方法不对任何对象进行操作，事实上，在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要
    的对象。每一个类可以有一个main方法，这是一个常用于对类进行单元测试的技巧。
    
#### 4.5 方法参数
  
    首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用（call by value）表示方法
    接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。一个方法可以
    修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。
    Java程序设计语言总是采用按值调用，也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的
    任何参数变量的内容。
    Java程序设计语言对对象采用的不是引用调用，实际上，对象引用进行的是指传递。Java语言中方法参数的使用情况：
    
    1.一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）
    2.一个方法可以改变一个对象参数的状态
    3.一个方法不能让对象参数应用一个新的对象。
    
#### 4.6 对象构造

##### 4.6.1 重载
    
    从前面看到，GregorianCalendar类有多个构造器，这种特征叫做重载（overloading）。如果多个方法，有相同的名字，
    不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用
    的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，或者找出多个可能的匹配，就会产生编译时错误（这
    个过程被称为重载解析（overloading resolution））
    
    Java允许重载任何方法，而不只是构造器方法，因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的
    签名（signature）。
    
##### 4.6.2 默认域初始化    

    如果在构造器中欧没有显示地给域赋初值，那么就会被自动地赋为默认值:数值为0、布尔值为false、对象引用为null。
    然而，只有缺少程序设计经验的人才会这样做。确实，如果不明确地对域进行初始化，就会影响程序代码的可读性。
 
    注：这是域与局部变量的主要不同点，必须明确初始化方法中的局部变量。但是如果没有初始化类中的域，将会被初始化
    为默认值（0、false、null）
    
##### 4.6.3 无参数的构造器
     
     很多类都包含了一个无参的构造函数，对象由无参数构造函数创建时，其状态会设置为适当的默认值。如果在编写一个类
     时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的
     数值型数据设置为0、布尔型数据设置为false、所有对象变量将设置为null。
     
     如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。
     
     注：仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。如果在编写类的时候，给出了一个构造器，
     哪怕是很简单的，要想让这个类的用户能够采用下列方式构造实例：
        new ClassName();
        就必须提供一个默认的构造器（即不带参数的构造器）。当然，如果希望所有域被赋予默认值，可以采用下列各式：
        public ClassName(){}
        
##### 4.6.4 显示域初始化
        
      由于类的构造器方法可以重载，所有可以采用多种形式设置类的实例域的初始化状态。确保如果怎样调用构造器，每个
      实例域都可以被设置为一个有意义的初值。这是一个很好的设计习惯。
      
##### 4.6.5 参数名
      
      通常，参数用单个字符命名，但是这样做有一个缺陷：只有阅读代码才能了解参数的含义。有一种技巧，它基于这样的事实
      参数变量用同样的名字将实例域屏蔽起来。this指示隐式参数，也就是被构造的对象。
      
##### 4.6.6 调用另一个构造器
     
     关键字this引用方法的隐式参数。然而，这个关键字还有另外一个含义。如果构造器的第一个语句形如：this(...)，
     这个构造器将调用同一个类的另一个构造器。
     采用这种方式使用this关键字非常有用，这样对公告的构造器代码部分只编写一次即可。
     
##### 4.6.7 初始化块
     
     两种初始化数据域的方法：
     1. 在构造器中设置值
     2. 在声明中赋值
     
     实际上，Java还有第三种机制，称为初始化块（initialization block）。在一个类的声明中，可以包含多个代码块。
     只要构造类的对象，这些代码块就会被执行。
     
     构造对象，首先运行初始化块，然后才运行构造器的主体部分。这种机制不是必需的，也不常见，通常，直接将初始化代码
     放在构造器中。建议将初始化块放在域定义之后
     
     由于初始化数据有多种途径，所有列出构造过程的所有路径可能相当混乱。下面是调用构造器的具体步骤：
     1. 所有数据域被初始化为默认值（0、false、null）
     2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。
     3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。
     4. 执行这个构造器的主体。
     
     当然，应该精心地组织好初始代码，这样有利于其他程序员的理解。例如，如果让类的构造器行为依赖于数据域声明的顺序
     那就会显得很奇怪并且容易引起错误。
     
     可以通过提供一个初始化值，或者使用一个静态的初始化来对静态域进行初始化。如果对类的静态域进行初始化的代码比较
     复杂，那么可以使用静态的初始化块。将代码放在一个块中，并标记关键字static。
     
     在类第一次加载的时候，将会进行静态域的初始化。与实例域一样，除非将它们显示地设置成其他值。否则默认的初始值是
     0、false或null。所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行。
     
     注：以上代码结构的执行顺序为， 静态代码块 > main方法 > 构造代码块 > 构造方法
     其中静态代码块只执行一次。构造代码块在每次创建对象时都会执行。
     
##### 4.6.8 对象析构与finalize方法     

    析构函数（destructor）与构造函数相反，当对象结束生命周期时，例如对象所在的函数已调用完毕。系统自动执行析构函数
    析构函数往往用来做"清理善后"的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）
    
    由于Java有自动垃圾回收器，不需要人工回收内存，所有Java不支持析构器。当然，某些对象使用了内存之外的其他资源，例如
    文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用显得十分重要。
    
    可以为任何一个类添加finalize方法，finalize方法将在垃圾回收器清除对象之间调用。在实际应用中，不要依赖于使用finalize
    方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能调用。
    
    如果某个资源需要在使用完毕后立刻被关闭，那么就需要由人工来管理。对象用完时，可以应用一个close方法来完成相应的清理
    操作。
    
#### 4.7 包
     
     Java允许使用包（package）将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理
     标准的Java类库分布在多个包中，包括Java.lang、java.util 和 Java.net 等。标准的Java包具有一个层次结构。如同硬盘
     的目录嵌套一样，也可以使用嵌套层组织包。所有标准的Java包都处于Java和Javax包层次中。
     
     sun公司建议将公司的英特网域名以逆序的形式作为包名，并且对于不同的项目使用不同的子包。

##### 4.7.1 类的导入
      
      一个类可以使用所属包中的所有类，以及其他包中的公有类（public class）。import语句是一种引用包含在包中的类的简明
      描述。一旦使用了import语句，在使用类时，就不必写出包的全名了。
      
##### 4.7.2 静态导入
      
      import语句不仅可以导入类，还增加了导入静态方法和静态域的功能。
      
##### 4.7.3 将类放入包中
      
      要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。如果没有在源文件中放置package语句。
      这个源文件中类就被放置在一个默认包（default package）中。默认包是一个没有名字的包。在此之前，我们定义的所有类
      都在默认包中。
      
##### 4.7.4 包作用域
      
      前面已经接触过访问修饰符public，private。标记为public的部分可以被任意的类使用；标记为private的部分只能被定义
      它们的类使用。如果没有指定public或private，这个部分（类，方法或变量）可以被同一个包中的所有方法访问。
      
      默认情况下，包不是一封闭的实体，也就是说，任何人都可以向包中添加更多的类，当然有敌意或低水平的程序员很可能利用包
      的可见性添加一些具有修改变量功能的代码。从1.2版开始。JDK的实现着修改了类加载器，明确地禁止加载用户自定义的，包
      名以"Java."开始的类。当然，用户自定义的类无法从这种保护中受益。然而，可以通过包密封（package sealing）机制
      来解决将各种包混杂在一起的问题。如果将一个包密封起来，就不能再向这个包添加类了。在第10章中，将介绍制作包含密封
      包的JAR文件的方法。
      
#### 4.8 类路径
      
      在前面已经看到，类存储在文件系统的子目录中。类的路径必须与包名匹配。
      
      另外，类文件也可以存储在JAR（Java归档）文件中。在一个JAR文件中，可以包含多个压缩形式的类文件和子目录，这样既
      可以节省又可以改善性能。在程序中用到第三方（third-party）的库文件时，通常会给出一个或多个需要包含的JAR文件。
      JDK也提供了许多的JAR文件。
      
      JAR文件使用ZIP格式组织文件和子目录。
      
      为了使类能够被多个程序共享，需要做到下面几点：
      1. 把类放到一个目录中，需要注意，这个目录是包树状结构的基目录。
      2. 将JAR文件防在一个目录中
      3. 设置类路径（class path），类路径是所有包含类文件的路径的集合。
      
      在UNIX环境中，类路径中的不同项目之间采用冒号（:）分隔。而在Windows环境中，则以分号（;）分隔。
      
      Java类路径告诉Java解析器和javac编译器去哪里找它们要执行或导入的类。
      
   ######设置类路径
      
      设置CLASSPATH,
      
#### 4.9 文档注释
      
    JDK包含一个很有用的工具，叫做Javadoc，它可以由源文件生成一个HTML文档。
      
##### 4.9.1 注释的插入
      
      javadoc实用程序从下面几个特性中抽取信息：
      包、 公有类与接口、 公有的受保护的构造器及方法、 公有的和受保护的域
      
##### 4.9.2 类注释
      
      类注释必须放在import语句之后。
      
##### 4.9.3 方法注释    
  
    每一个方法注释必须放在所描述的方法之前。除通用标记之外，还可以使用下面标记：
    1.@param，变量描述 ——方法的参数
    2.@return 描述， ——方法返回部分
    3.@throws 类描述，——表示这个方法有可能抛出异常
    
##### 4.9.4 域注释
       
    只需要对公有域（通常指的是静态常量）建立文档
    
##### 4.9.5 通用注释      
     
    @author 标记将产生一个"author"条目，可以使用多个@author标记，每个@author标记对应一名作者
    @version 标记将产生一个"version"条目，这里的文本可以是对当前版本的任何描述。
    @since 标记产生一个"since"（始于）条目，这里的文本可以是对引入特性的版本描述
    @deprecated 标记将对类，方法或变量添加一个不再使用的注释。
    @see 标记将在"see also" 部分增加一个超级链接。它可以用于类中，也可以用于方法中。
       如：@see com.horstmann.corejava.Employee#raiseSalary(double)
       建立了一个链接到com.horstmann.corejava.Employee类的raiseSalary(double)方法的超链接
       
       @see标记后面有一个< 字符，就需要指定一个超链接。可以超链接到任何URL
       如：@see <a href="www.horstman.com/corejava.html">The Core java home page</a>
       
       以上情况，都可以指定一个可选的标签（label）作为链接锚（link anchor）。如果省略了label，用户看到的锚
       的名称就是目标代码名或URL.
       
       如果@see 标记后面有一个双引号（"）字符，文本就会显示在 "see also"部分。
       如：@see "core Java 2 volume 2"
       
       如果愿意的话，可以在注释中的任何位置放置指向其他类或方法的超级链接，以及插入一个专用的标记
       如：{@link package.class #feature label}，该描述规则与@see标记规则一样。
       
##### 4.9.6 包与概述注释          

    可以直接将类，方法和变量的注释放置在Java源文件中，只要用/**....*/文档注释界定就可以了。但是，要想产生包注释，
    就需要在每一个包目录中添加一个单独的文件。有两种选择：
    1.提供一个以package.html 命名的HTML 文件。在标记<body>...</body>之间的所有文本都会被抽取出来。
    2.提供一个以package-info.java 命名的Java文件，这个文本必须包含一个初始的以/**....*/界定的javadoc注释，跟随在一个
    包语句之后。它不应该包含更多的代码或注释。
    
    还可以为所有的源文件提供一个概述性的注释。这个注释将被放置在一个名为overview.html的文件中，这个文件位于包所有源文件的
    父目录中。标记<body>...</body>之间的所有文本都会被抽取出来。当用户从导航栏中选择"Overview"时，就会出现这些注释内容。
       
    
##### 4.9.7 注释的抽取
       
    这里，假设HTML文件将被存放在目录docDirectory下。执行如下步骤
    1）切换到包含想要生成文档的源文件目录。如果有嵌套的包要生成文档，如com.horstmann.corejava,就必须切换到包含于目录com
    的目录（如果存在overview.html 文件的话，这也是它的所在目录）
    2）如果是一个包，应该运行命令
    javadoc -d docDirectory nameOfPackage
    或对于多个包生成文档，就应该运行:
    javadoc -d docDirectory nameOfPackage1 nameOfPackage2 ...
    如果文件在默认包中，就应该
    javadoc -d docDirectory *.java 
    如果省略了-d docDirectory 选项，那HTML 文件就会被提取到当前目录下。这样有可能带来混乱，因此不提倡这种做法。
    
#### 4.10 类设计技巧

    简单地介绍几点技巧，应用这些技巧可言使设计出来的类更具有OOP的专业水准。
    
    1）一定要保证数据私有。
    这是最重要的，绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。很多惨痛的
    经验告诉我们，数据的表示形式很可能会改变，但它们的使用方法却不会经常发生变化。当数据保持私有时，它们的表示形式的变化不会
    对类的使用者产生影响，即使出现bug也易于检测。
    
    2）一定要对数据初始化
    Java不对局部变量进行初始化，但是会对对象的实例域进行初始化。最好不要依赖于系统的默认值，而是应该显式地初始化所有的数据
    具体的初始化方法可以是提供默认值，也可以是在所有的构造器中设置默认值。
    
    3）不要在类中使用过多的基本类型
    就是说，用其他的类代替多个相关的基本类型的使用。这样会使类更加易于理解且易于修改。如:用一个称为Address的新的类替换一个
    Customer类中有关的实例域。这样，很容易处理地址的变化，如需要增加对国家地址的处理。
    
    4）不要所有的域都需要独立的域访问器和域更改器。
    或许，需要获得或设置雇员的薪金。而一旦构造了雇员对象，就应该禁止更改雇用日期，并且在对象中，常常包含一些不希望别人获得
    或设置的实例域。
    
    5）将职责过多的类进行分解
    这样说有点含糊不清，究竟多少算是"过多"？每个人的看法不同。但是，如果明显地可以将一个复杂的类分解成两个更为简单的类，
    就应该将其分解（但另一方面，也不要走极端。设计10个类，每个类只有一个方法，显然有点矫枉过正了）
    
    6）类名和方法名要能够体现它们的职责。
    与变量应该有一个能够反映其含义的名字一样，类也应该如此。
    命名类名的良好习惯是采用一个名词（Order）,前面有形容词修饰的名词或动名词（有'-ing'后缀）修饰名词。
    对应方法来说，习惯是访问器方法用小写get开头，更改器方法用小写的set开头。
   
     
     
     
     
     
     
     
     
      
        
    