### 第四章 对象与类

    
#### 4.1 面向对象程序设计概述

    面向对象程序设计（简称OOP)是当今主流的程序设计范型，它已经取代了20世纪70年代的“结构化”过程化程序
    设计开发技术。java是完全面向对象的。
    
    面向对象的程序是由对象组成的，每个对象包对用户公开的特定的功能部分和隐藏的实现部分。程序中的很多
    对象来自标准库，还有一些是自定义的。从根本上说，只要对象能够满足要求，就不必关心其功能的具体实现过程。
    在OOP中，不必关心对象的具体实现，只要能够满足用户的需求即可。
    
    
    传统的结构化程序设计通过设计一系列的过程（即算法）来解决问题。一旦确定了这些过程，就要开始考虑
    存储数据的方式。这就是Pascal语言的设计者Niklaus Wirth 将其著作命名为《算法+数据结构=程序》（Algorithms+
    Data Structures = Programs， Prentice Hall 1975）的原因。在Wirth命名的书名中，算法是第一位的，数据
    结构是第二位的，这就明确地表述了程序员的工作方式，首页要确定如何操作数据，然后再决定如何组织数据，以便于
    数据操作。而OOP却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。
    
    对于一些规模较小的问题，将其分解为过程的开发方式比较理想。而面向对象更加适用于解决规模较大的问题。
    
##### 4.1.1 类

    类（class）是构造对象的模板或蓝图。问可以将类想象成制作小甜饼的切割机，将类想象为小甜饼。
    由类构造（construct）对象的过程称为创建类的实例（instance）。
    
    封装（encapsulation，有时称为数据隐藏）与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合
    在一个包中，并对对象的使用者隐藏了数据的实现方式。
    
    对象中的数据称为实例域（instance field），操纵数据的过程称为方法（method）。对于每个特定的类实例（对象）
    都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state）。无论如何，只要向对象发送一个消息，
    它的状态就有可能发生改变。
    
    实现封装的关键在于绝不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。
    封装给对象赋予了“黑盒”特征，这是提高重用性和可靠性的关键。
    
    OOP的另一个原则会让用户自定义java类变得轻而易举，这就是：可以通过扩展一个类来建立另外一个新的类。事实上，
    在java中，所有的类都源自于一个“神通广大的超类”，他就是Object。在扩展一个已有的类时，这个扩展后的新类
    具有所扩展类的全部属性和方法。
    
    
##### 4.1.2 对象 

    要想使用OOP,一定要弄清楚对象的三个特征
    对象的行为（behavior）——可以对对象施加哪些操作，或可以对对象施加哪些方法？
    对象的状态（state）——当施加那些方法时，对象如何响应？
    对象的标识（identity）—— 如何辨别具有相同行为与状态的不同对象？
    
    同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。
    
    每个对象对保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会
    是自发的。对象的状态改变必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明封装性遭到破坏）

    对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份（identity）.作为一个类的实例，每个对象的标识
    永远是不同的，状态常常也存在着差异。
    
    对象的这些关键特性在彼此之间相互影响者。对象的状态影响它的行为（如果一个订单“已送货”或“已付款”，就应该
    拒绝调用具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预订的物品，这个订单就不应该进入
    “已送货”状态）。
    
##### 4.1.3 识别类
    
    传统的过程化程序设计，必须从顶部的main函数开始编写程序。在面向对象程序设计时没有所谓的“顶部”。对于学习OOP
    的初学者来说常常会感觉无从下手。答案是：首先从设计类开始，然后再往每个类中添加方法。
    
    识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
    如：在订单处理系统中，有这样一些名词：
    项目（item）
    订单（order）
    送货地址（shipping address）
    付款（payment）
    账户（account）
    
##### 4.1.4 类之间的关系

    在类之间，最常见的关系有
    1. 依赖（“uses-a”）
    2. 聚合（“has-a”）
    3. 继承 （“is-a”）   
     
    依赖（dependence），即“uses-a”关系，是一种最明显的，最常见的关系。如：Order类使用Account类是因为
    Order对象需要访问Account对象查看信用状态。但是Item类不依赖于Account类，这是因为Item对象于客户无关。
    因此，如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类
    
    应该尽可能地将相互依赖的类减至最少。如果类A不知道B的存在，它就不会关心B的任何改变（这意味着B的改变
    不会导致A产生任何bug）。用软件工程的术语来说，就说让类之间的耦合度最小。
    
    聚合（aggregation），即“has-a”关系，是一个具体且易于理解的关系。如：一个Order对象包含一些Item对象。
    聚合关系意味着类A的对象包含类B的对象。
    
    继承（inheritance），即“is-a”关系，是一种用于表示特殊与一般关系的。如：RushOrder类由Order类继承而来。
    在具有特殊性的RushOrder类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法；而其他方法，
    如添加条目，生成账单等都是从order类继承来到。
    
    
     
    
#### 4.2  使用预定义类

    在java中，没有类就无法做任何事情。
    
##### 4.2.1  对象与对象变量

    要想使用对象，就必须首先构造对象，并制定其初始状态，在java程序设计语言中，使用构造器（constructor）
    构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。
    
    一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在java中，任何对象变量的值都是对存储在另外
    一个地方的一个对象的引用。new操作符的返回值也是一个引用。
    
##### 4.2.2  java类库中的GregorianCalendar类
    
    类库设计者决定将保持实际与给时间点命名分开。所以标准java类库分别包含了两个类：一个用来表示时间点的Date类，
    另一个是用来表示大家熟悉的日历表示法的GregorianCalendar类。事实上，GregorianCalendar类扩展了一个更加通用的
    Calendar类，这个类描述了日历的一般属性。
    
##### 4.2.3  更改器方法和访问器方法
   
    get方法与set和add方法在概念上是有区别的。get方法仅仅查看并返回对象的状态，而set和add方法却对对象的状态
    进行修改。对实例域做出修改的方法称为更改器方法（mutator method），仅访问实例域而不进行修改的方法称为
    访问器方法（accessor method）。在C++中，带有const后缀的方法时访问器方法；默认为更改器方法。
    
#### 4.3 用户自定义类
    
##### 4.3.1 Employee类

    在一个源文件中，只能有一个公共类，但可以有任意数目的非公有类。
    
##### 4.3.2 多个源文件的使用
   
    当java编译器发现EmployeeTest.java 使用了Employee类时会查找类名为Employee.class文件。如果没有找到这个文件，
    就会自动地搜索Employee.java，然后，对它进行编译。更重要的是：如果Employee.java版本较已有的Employee.class
    文件版本新，java编译器就会自动地重新编译这个文件。
    
    如果熟悉UNIX的“make”工具（或者Windows中的“nmake”等工具），可以认为java编译器内置了“make”功能。
 
##### 4.3.3 剖析Employee类

    类中的方法都被标记为public，关键字private确保只有类自身的方法能够访问这些实例域，而其他类的
    方法不能读写这些域。
    
##### 4.3.4 从构造器开始

    构造器与其他的方法有一个重要的不同。构造器总是伴随着new操作符的执行被调用，而不能对一个已经
    存在的对象调用构造器来达到重新设置实例域的目的。其特点有：
    1.构造器与类名同名
    2.每个类可以有一个以上构造器
    3.构造器可以有0个，1个或多个参数
    4.构造器没有返回值
    5.构造器总是伴随着new操作一起调用
    
    必须注意在所有的方法中不要命名与实例域同名的变量。
    
    
##### 4.3.5 隐式参数与显式参数

    public void raiseSalary(double byPercent)
    {
      double raise = salary * byPercent / 100;
      salary += raise;
    }
    该方法有两个参数，第一个参数称为隐式（implicit）参数，是出现在方法名前的Employee类对象，第二个参数
    位于方法名后面括号中的数值，这是一个显式（explicit）参数。
    
    关键字this表示隐式参数。
   
##### 4.3.6 封装的优点

    在需要获取或设置实例域的值，应提供以下三项：
    1. 一个私有的数据域
    2. 一个公有的域访问器方法
    3. 一个公有的域更改器方法
    
    这样做要比提供一个简单的公有数据域复杂些，但是却有着下列明显的好处：
    1.可以改变内部实现，除了该类的方法之外，不会影响其他代码。
    2. 更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。
    
    不要编写返回引用可变对象的访问器方法。如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone），
    对象clone是指存放在另一个位置上的对象副本。
    
##### 4.3.7 基于类的访问权限

    方法可以访问所属类的私有特性（feature），而不仅限于访问隐式参数的私有特性。

##### 4.3.8 私有方法

    在实现一个类时，由于公有数据非常危险，所以应该将所有的数据域都设置为私有的。尽管绝大多数方法都被设计为
    公有的，但在某些特殊情况下，也可能将他们设计为私有的。
    
##### 4.3.9 final实例域

    final修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域（如果类中的每个方法都不会改变
    其对象，这种类就是不可变的类，如：String）。对于可变的类，使用final修饰符可能会对读者造成混乱。
    
#### 4.4 静态域域静态方法
    
##### 4.4.1 静态域

    如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。如：
    class Employee
    {
        //静态域
        private static int nextId = 1;
        //实例域
        private int id;
     }
     这样，每一个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个nextId域。换句话说，如果有1000个
     Employee类的对象，则有1000个实例域id。但是，只有一个静态域nextId。
     
##### 4.4.2 静态常量

    静态变量使用得比较少，但静态常量却使用得比较多。